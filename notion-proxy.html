<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notion API Proxy for Figma Plugin</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        }
        p {
            color: #666;
            line-height: 1.6;
            margin: 0 0 15px 0;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
        }
        .status.ready {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Notion API Proxy</h1>
        <p>This proxy server enables Figma plugins to communicate with the Notion API by bypassing CORS restrictions.</p>
        <div id="status" class="status ready" style="display: none;">
            âœ“ Proxy is ready and waiting for requests from the Figma plugin.
        </div>
    </div>

    <script>
        (function() {
            'use strict';

            // Configuration
            const ALLOWED_ORIGINS = ['null', 'https://www.figma.com', 'https://figma.com'];
            const NOTION_API_BASE = 'https://api.notion.com/v1';
            const READY_TIMEOUT = 5000;

            let isReady = false;
            let statusEl = document.getElementById('status');

            /**
             * Validates the origin of incoming messages for security
             */
            function isValidOrigin(origin) {
                if (!origin) {
                    // null origin is expected from Figma plugins
                    return true;
                }
                
                // Allow Figma domains and null origin
                return ALLOWED_ORIGINS.some(allowed => 
                    origin === allowed || origin.includes('figma.com')
                );
            }

            /**
             * Handles incoming messages from the Figma plugin
             */
            window.addEventListener('message', async (event) => {
                // Security: Validate origin
                if (!isValidOrigin(event.origin)) {
                    console.warn('[Notion Proxy] Rejected message from unauthorized origin:', event.origin);
                    return;
                }

                // Verify we have a source to respond to
                if (!event.source || !event.source.postMessage) {
                    console.warn('[Notion Proxy] Invalid message source');
                    return;
                }

                const { type, payload } = event.data || {};

                // Handle notion-request messages
                if (type === 'notion-request' && payload) {
                    try {
                        const { endpoint, method = 'GET', headers = {}, body } = payload;

                        // Validate endpoint to prevent SSRF attacks
                        if (!endpoint || typeof endpoint !== 'string') {
                            throw new Error('Invalid endpoint');
                        }

                        // Ensure endpoint starts with / to prevent protocol-relative URLs
                        const safeEndpoint = endpoint.startsWith('/') ? endpoint : '/' + endpoint;
                        
                        // Construct full URL
                        const url = `${NOTION_API_BASE}${safeEndpoint}`;

                        // Prepare fetch options
                        const fetchOptions = {
                            method: method,
                            headers: {
                                ...headers,
                                // Ensure required Notion API headers are present
                                'Notion-Version': headers['Notion-Version'] || '2022-06-28',
                            },
                        };

                        // Add body if present
                        if (body && (method === 'POST' || method === 'PATCH' || method === 'PUT')) {
                            fetchOptions.body = typeof body === 'string' ? body : JSON.stringify(body);
                            if (!fetchOptions.headers['Content-Type']) {
                                fetchOptions.headers['Content-Type'] = 'application/json';
                            }
                        }

                        // Make the request to Notion API
                        const response = await fetch(url, fetchOptions);
                        
                        // Parse response
                        let responseData;
                        const contentType = response.headers.get('content-type');
                        
                        if (contentType && contentType.includes('application/json')) {
                            responseData = await response.json();
                        } else if (response.status === 204) {
                            // No content
                            responseData = {};
                        } else {
                            // Try to parse as text
                            responseData = { message: await response.text() };
                        }

                        // Send response back to plugin
                        event.source.postMessage({
                            type: 'notion-response',
                            success: response.ok,
                            status: response.status,
                            statusText: response.statusText,
                            data: responseData,
                        }, '*');

                    } catch (error) {
                        console.error('[Notion Proxy] Error processing request:', error);
                        
                        // Send error response back to plugin
                        if (event.source && event.source.postMessage) {
                            event.source.postMessage({
                                type: 'notion-response',
                                success: false,
                                status: 0,
                                error: error.message || 'Unknown error occurred',
                                data: null,
                            }, '*');
                        }
                    }
                }
            });

            /**
             * Signal that the proxy is ready
             */
            function signalReady() {
                if (window.parent && window.parent !== window) {
                    try {
                        window.parent.postMessage({ 
                            type: 'proxy-ready',
                            timestamp: Date.now()
                        }, '*');
                        isReady = true;
                        
                        // Show status indicator
                        if (statusEl) {
                            statusEl.style.display = 'block';
                        }
                        
                        console.log('[Notion Proxy] Ready and waiting for requests');
                    } catch (error) {
                        console.error('[Notion Proxy] Error signaling ready:', error);
                    }
                }
            }

            // Signal ready when page loads
            if (document.readyState === 'loading') {
                window.addEventListener('load', signalReady);
            } else {
                signalReady();
            }

            // Also signal ready after a short delay as a fallback
            setTimeout(signalReady, 100);

            // Expose ready state for debugging
            window.notionProxyReady = () => isReady;

        })();
    </script>
</body>
</html>
